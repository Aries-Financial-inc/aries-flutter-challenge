// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'risk_and_reward_state_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

RiskAndRewardState _$RiskAndRewardStateFromJson(Map<String, dynamic> json) {
  return _RiskAndRewardState.fromJson(json);
}

/// @nodoc
mixin _$RiskAndRewardState {
  List<OptionModel> get options => throw _privateConstructorUsedError;
  double get maxProfit => throw _privateConstructorUsedError;
  double get maxLoss => throw _privateConstructorUsedError;
  List<double> get breakEvenPoints => throw _privateConstructorUsedError;
  bool get isLoading => throw _privateConstructorUsedError;
  @FlSpotConverter()
  List<FlSpot> get spots => throw _privateConstructorUsedError;
  double get minX => throw _privateConstructorUsedError;
  double get maxX => throw _privateConstructorUsedError;
  double get minY => throw _privateConstructorUsedError;
  double get maxY => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RiskAndRewardStateCopyWith<RiskAndRewardState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RiskAndRewardStateCopyWith<$Res> {
  factory $RiskAndRewardStateCopyWith(
          RiskAndRewardState value, $Res Function(RiskAndRewardState) then) =
      _$RiskAndRewardStateCopyWithImpl<$Res, RiskAndRewardState>;
  @useResult
  $Res call(
      {List<OptionModel> options,
      double maxProfit,
      double maxLoss,
      List<double> breakEvenPoints,
      bool isLoading,
      @FlSpotConverter() List<FlSpot> spots,
      double minX,
      double maxX,
      double minY,
      double maxY});
}

/// @nodoc
class _$RiskAndRewardStateCopyWithImpl<$Res, $Val extends RiskAndRewardState>
    implements $RiskAndRewardStateCopyWith<$Res> {
  _$RiskAndRewardStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? options = null,
    Object? maxProfit = null,
    Object? maxLoss = null,
    Object? breakEvenPoints = null,
    Object? isLoading = null,
    Object? spots = null,
    Object? minX = null,
    Object? maxX = null,
    Object? minY = null,
    Object? maxY = null,
  }) {
    return _then(_value.copyWith(
      options: null == options
          ? _value.options
          : options // ignore: cast_nullable_to_non_nullable
              as List<OptionModel>,
      maxProfit: null == maxProfit
          ? _value.maxProfit
          : maxProfit // ignore: cast_nullable_to_non_nullable
              as double,
      maxLoss: null == maxLoss
          ? _value.maxLoss
          : maxLoss // ignore: cast_nullable_to_non_nullable
              as double,
      breakEvenPoints: null == breakEvenPoints
          ? _value.breakEvenPoints
          : breakEvenPoints // ignore: cast_nullable_to_non_nullable
              as List<double>,
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      spots: null == spots
          ? _value.spots
          : spots // ignore: cast_nullable_to_non_nullable
              as List<FlSpot>,
      minX: null == minX
          ? _value.minX
          : minX // ignore: cast_nullable_to_non_nullable
              as double,
      maxX: null == maxX
          ? _value.maxX
          : maxX // ignore: cast_nullable_to_non_nullable
              as double,
      minY: null == minY
          ? _value.minY
          : minY // ignore: cast_nullable_to_non_nullable
              as double,
      maxY: null == maxY
          ? _value.maxY
          : maxY // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RiskAndRewardStateImplCopyWith<$Res>
    implements $RiskAndRewardStateCopyWith<$Res> {
  factory _$$RiskAndRewardStateImplCopyWith(_$RiskAndRewardStateImpl value,
          $Res Function(_$RiskAndRewardStateImpl) then) =
      __$$RiskAndRewardStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<OptionModel> options,
      double maxProfit,
      double maxLoss,
      List<double> breakEvenPoints,
      bool isLoading,
      @FlSpotConverter() List<FlSpot> spots,
      double minX,
      double maxX,
      double minY,
      double maxY});
}

/// @nodoc
class __$$RiskAndRewardStateImplCopyWithImpl<$Res>
    extends _$RiskAndRewardStateCopyWithImpl<$Res, _$RiskAndRewardStateImpl>
    implements _$$RiskAndRewardStateImplCopyWith<$Res> {
  __$$RiskAndRewardStateImplCopyWithImpl(_$RiskAndRewardStateImpl _value,
      $Res Function(_$RiskAndRewardStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? options = null,
    Object? maxProfit = null,
    Object? maxLoss = null,
    Object? breakEvenPoints = null,
    Object? isLoading = null,
    Object? spots = null,
    Object? minX = null,
    Object? maxX = null,
    Object? minY = null,
    Object? maxY = null,
  }) {
    return _then(_$RiskAndRewardStateImpl(
      options: null == options
          ? _value._options
          : options // ignore: cast_nullable_to_non_nullable
              as List<OptionModel>,
      maxProfit: null == maxProfit
          ? _value.maxProfit
          : maxProfit // ignore: cast_nullable_to_non_nullable
              as double,
      maxLoss: null == maxLoss
          ? _value.maxLoss
          : maxLoss // ignore: cast_nullable_to_non_nullable
              as double,
      breakEvenPoints: null == breakEvenPoints
          ? _value._breakEvenPoints
          : breakEvenPoints // ignore: cast_nullable_to_non_nullable
              as List<double>,
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      spots: null == spots
          ? _value._spots
          : spots // ignore: cast_nullable_to_non_nullable
              as List<FlSpot>,
      minX: null == minX
          ? _value.minX
          : minX // ignore: cast_nullable_to_non_nullable
              as double,
      maxX: null == maxX
          ? _value.maxX
          : maxX // ignore: cast_nullable_to_non_nullable
              as double,
      minY: null == minY
          ? _value.minY
          : minY // ignore: cast_nullable_to_non_nullable
              as double,
      maxY: null == maxY
          ? _value.maxY
          : maxY // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RiskAndRewardStateImpl
    with DiagnosticableTreeMixin
    implements _RiskAndRewardState {
  _$RiskAndRewardStateImpl(
      {final List<OptionModel> options = const [],
      this.maxProfit = 0,
      this.maxLoss = 0,
      final List<double> breakEvenPoints = const [],
      this.isLoading = false,
      @FlSpotConverter() final List<FlSpot> spots = const [],
      this.minX = 0,
      this.maxX = 0,
      this.minY = 0,
      this.maxY = 0})
      : _options = options,
        _breakEvenPoints = breakEvenPoints,
        _spots = spots;

  factory _$RiskAndRewardStateImpl.fromJson(Map<String, dynamic> json) =>
      _$$RiskAndRewardStateImplFromJson(json);

  final List<OptionModel> _options;
  @override
  @JsonKey()
  List<OptionModel> get options {
    if (_options is EqualUnmodifiableListView) return _options;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_options);
  }

  @override
  @JsonKey()
  final double maxProfit;
  @override
  @JsonKey()
  final double maxLoss;
  final List<double> _breakEvenPoints;
  @override
  @JsonKey()
  List<double> get breakEvenPoints {
    if (_breakEvenPoints is EqualUnmodifiableListView) return _breakEvenPoints;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_breakEvenPoints);
  }

  @override
  @JsonKey()
  final bool isLoading;
  final List<FlSpot> _spots;
  @override
  @JsonKey()
  @FlSpotConverter()
  List<FlSpot> get spots {
    if (_spots is EqualUnmodifiableListView) return _spots;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_spots);
  }

  @override
  @JsonKey()
  final double minX;
  @override
  @JsonKey()
  final double maxX;
  @override
  @JsonKey()
  final double minY;
  @override
  @JsonKey()
  final double maxY;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'RiskAndRewardState(options: $options, maxProfit: $maxProfit, maxLoss: $maxLoss, breakEvenPoints: $breakEvenPoints, isLoading: $isLoading, spots: $spots, minX: $minX, maxX: $maxX, minY: $minY, maxY: $maxY)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'RiskAndRewardState'))
      ..add(DiagnosticsProperty('options', options))
      ..add(DiagnosticsProperty('maxProfit', maxProfit))
      ..add(DiagnosticsProperty('maxLoss', maxLoss))
      ..add(DiagnosticsProperty('breakEvenPoints', breakEvenPoints))
      ..add(DiagnosticsProperty('isLoading', isLoading))
      ..add(DiagnosticsProperty('spots', spots))
      ..add(DiagnosticsProperty('minX', minX))
      ..add(DiagnosticsProperty('maxX', maxX))
      ..add(DiagnosticsProperty('minY', minY))
      ..add(DiagnosticsProperty('maxY', maxY));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RiskAndRewardStateImpl &&
            const DeepCollectionEquality().equals(other._options, _options) &&
            (identical(other.maxProfit, maxProfit) ||
                other.maxProfit == maxProfit) &&
            (identical(other.maxLoss, maxLoss) || other.maxLoss == maxLoss) &&
            const DeepCollectionEquality()
                .equals(other._breakEvenPoints, _breakEvenPoints) &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            const DeepCollectionEquality().equals(other._spots, _spots) &&
            (identical(other.minX, minX) || other.minX == minX) &&
            (identical(other.maxX, maxX) || other.maxX == maxX) &&
            (identical(other.minY, minY) || other.minY == minY) &&
            (identical(other.maxY, maxY) || other.maxY == maxY));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_options),
      maxProfit,
      maxLoss,
      const DeepCollectionEquality().hash(_breakEvenPoints),
      isLoading,
      const DeepCollectionEquality().hash(_spots),
      minX,
      maxX,
      minY,
      maxY);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RiskAndRewardStateImplCopyWith<_$RiskAndRewardStateImpl> get copyWith =>
      __$$RiskAndRewardStateImplCopyWithImpl<_$RiskAndRewardStateImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RiskAndRewardStateImplToJson(
      this,
    );
  }
}

abstract class _RiskAndRewardState implements RiskAndRewardState {
  factory _RiskAndRewardState(
      {final List<OptionModel> options,
      final double maxProfit,
      final double maxLoss,
      final List<double> breakEvenPoints,
      final bool isLoading,
      @FlSpotConverter() final List<FlSpot> spots,
      final double minX,
      final double maxX,
      final double minY,
      final double maxY}) = _$RiskAndRewardStateImpl;

  factory _RiskAndRewardState.fromJson(Map<String, dynamic> json) =
      _$RiskAndRewardStateImpl.fromJson;

  @override
  List<OptionModel> get options;
  @override
  double get maxProfit;
  @override
  double get maxLoss;
  @override
  List<double> get breakEvenPoints;
  @override
  bool get isLoading;
  @override
  @FlSpotConverter()
  List<FlSpot> get spots;
  @override
  double get minX;
  @override
  double get maxX;
  @override
  double get minY;
  @override
  double get maxY;
  @override
  @JsonKey(ignore: true)
  _$$RiskAndRewardStateImplCopyWith<_$RiskAndRewardStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
